# -*- coding: utf-8 -*-
"""Metodo_Sammon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7s_v8Q57SJk8Y_xneik2hfsenMvuZ5T
"""

# Sammon
X = new_data
n = 2
# Numero maximo de iteraciones
maxiter = 500
# Tolerancia de error
tolfun = 1e-9
N, dim = X.shape
scale = 0.5 / np.sum(dist_m)
# Y aleatorio
Y = np.random.rand(N, n)
E = 0  # Error inicial

for _ in range(maxiter):
    # Calcula las distancias en el espacio Y
    dist_y = np.zeros((N, N))
    for i in range(N):
        for j in range(i + 1, N):
            p1 = Y[i]
            p2 = Y[j]
            sum = 0
            for z in range(n):  # Itera sobre las dimensiones de Y
                sum += (p1[z] - p2[z]) ** 2
            euclidiana_y = math.sqrt(sum)
            dist_y[i][j] = euclidiana_y
            dist_y[j][i] = euclidiana_y

    yD = np.array(dist_y)
    yD[yD == 0] = 1e-10  # Evita divisiones por cero

    # Calcula las diferencias entre las distancias en X y Y
    delta = dist_m - yD
    E_new = np.sum((delta**2) / (dist_m**2))

    # Detiene la optimización si la mejora es pequeña
    if np.abs((E - E_new) / E) < tolfun:
        break

    E = E_new  # Actualiza el error

    # Actualiza las posiciones en Y
    for i in range(N):
        for k in range(n):
            gradient = 0
            for j in range(N):
                if i != j:
                    gradient += (delta[i][j] / dist_m[i][j] - delta[i][j] / yD[i][j]) * (Y[i][k] - Y[j][k])
            Y[i][k] = Y[i][k] - scale * gradient

print(Y)